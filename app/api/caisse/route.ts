import { NextRequest, NextResponse } from 'next/server'
import { getSession } from '@/lib/auth'
import { prisma } from '@/lib/db'
import { comptabiliserCaisse } from '@/lib/comptabilisation'
import { getEntiteId } from '@/lib/get-entite-id'

export async function GET(request: NextRequest) {
  const session = await getSession()
  if (!session) return NextResponse.json({ error: 'Non autorisé' }, { status: 401 })

  const limit = Math.min(200, Math.max(1, Number(request.nextUrl.searchParams.get('limit')) || 100))
  const dateDebut = request.nextUrl.searchParams.get('dateDebut')?.trim()
  const dateFin = request.nextUrl.searchParams.get('dateFin')?.trim()
  const magasinIdParam = request.nextUrl.searchParams.get('magasinId')?.trim()
  const typeParam = request.nextUrl.searchParams.get('type')?.trim()

  const where: {
    date?: { gte: Date; lte: Date }
    magasinId?: number
    type?: string
  } = {}

  if (dateDebut && dateFin) {
    where.date = {
      gte: new Date(dateDebut + 'T00:00:00'),
      lte: new Date(dateFin + 'T23:59:59'),
    }
  }

  if (magasinIdParam) {
    const magId = Number(magasinIdParam)
    if (Number.isInteger(magId) && magId > 0) where.magasinId = magId
  }

  if (typeParam && ['ENTREE', 'SORTIE'].includes(typeParam)) {
    where.type = typeParam
  }

  const operations = await prisma.caisse.findMany({
    where,
    take: limit,
    orderBy: { date: 'desc' },
    include: {
      magasin: { select: { id: true, code: true, nom: true } },
      utilisateur: { select: { nom: true, login: true } },
    },
  })

  return NextResponse.json(operations)
}

export async function POST(request: NextRequest) {
  const session = await getSession()
  if (!session) return NextResponse.json({ error: 'Non autorisé' }, { status: 401 })

  try {
    const body = await request.json()
    const date = body?.date ? new Date(body.date) : new Date()
    const magasinId = Number(body?.magasinId)
    const type = ['ENTREE', 'SORTIE'].includes(String(body?.type || '').toUpperCase())
      ? String(body.type).toUpperCase()
      : 'ENTREE'
    const motif = String(body?.motif || '').trim()
    const montant = Math.max(0, Number(body?.montant) || 0)

    if (!Number.isInteger(magasinId) || magasinId <= 0) {
      return NextResponse.json({ error: 'Magasin requis.' }, { status: 400 })
    }
    if (!motif) {
      return NextResponse.json({ error: 'Motif requis.' }, { status: 400 })
    }
    if (montant <= 0) {
      return NextResponse.json({ error: 'Montant doit être supérieur à 0.' }, { status: 400 })
    }

    const magasin = await prisma.magasin.findUnique({ where: { id: magasinId } })
    if (!magasin) {
      return NextResponse.json({ error: 'Magasin introuvable.' }, { status: 400 })
    }
    
    // Utiliser l'entité de la session
    const entiteId = await getEntiteId(session)
    
    // Vérifier que le magasin appartient à l'entité sélectionnée (sauf SUPER_ADMIN)
    if (session.role !== 'SUPER_ADMIN' && magasin.entiteId !== entiteId) {
      return NextResponse.json({ error: 'Ce magasin n\'appartient pas à votre entité.' }, { status: 403 })
    }

    const operation = await prisma.caisse.create({
      data: {
        date,
        magasinId,
        type,
        motif,
        montant,
        utilisateurId: session.userId,
      },
      include: {
        magasin: { select: { id: true, code: true, nom: true } },
        utilisateur: { select: { nom: true, login: true } },
      },
    })

    // Comptabilisation automatique
    try {
      await comptabiliserCaisse({
        caisseId: operation.id,
        date,
        type: type as 'ENTREE' | 'SORTIE',
        montant,
        motif,
        utilisateurId: session.userId,
      })
    } catch (comptaError) {
      console.error('Erreur comptabilisation caisse:', comptaError)
      // On continue même si la comptabilisation échoue
    }

    return NextResponse.json(operation)
  } catch (e) {
    console.error('POST /api/caisse:', e)
    return NextResponse.json(
      { error: 'Erreur serveur.' },
      { status: 500 }
    )
  }
}
